as.matrix(dist(location))[6,8]
# Compute the "stress": the higher it is, the worse
# the matching between original distances and their
# geometrical representation through MDS
Stressk <- NULL
for(k in 1:4)
?rexp
task1_time =  rexp(10, rate = 0.3)
task2_time = rexp(10, rate = 0.5)
task3_time = rexp(10, rate = 0.4)
task4_time = rexp(10, rate = 0.8)
task10_time = rexp(10, rate = 0.8)
task5_time = rexp(10, rate = 0.6)
task6_time = rexp(10, rate = 1)
task7_time = rexp(10, rate= 0.2)
task8_time = rexp(10, rate = 0.8)
task9_time = rexp(10, rate = 0.1)
task10_time = rexp(10, rate = 0.8)
firstgroup = rbind(task1_time, task2_time, task3_time, task4_time, task5_time)
View(firstgroup)
?round
firstgroup = ceiling(firstgroup)
View(firstgroup)
firstgroup = rbind(task1_time, task2_time, task3_time, task4_time, task5_time)
firstgroup = ronud(firstgroup, digits: 1)
firstgroup = round(firstgroup, digits: 1)
firstgroup = round(firstgroup, digits= 1)
or(i in (1:5))
for(j in (1:10))
if (firstgroup[i,j] < 0.4) {
firstgroup[i,j] = 0
}
for(i in c(1:5))
for(j in c(1:10))
if (firstgroup[i,j] < 0.4) {
firstgroup[i,j] = 0
}
View(firstgroup)
View(firstgroup)
install.packages('rstan')
install.packages("swirl")
swirl()
library("swirl")
swirl()
12
5 + 7
x <- 5 = + 7
x <- 5  + 7
x
y <- x - 3
y
z <- c(1.1, 9, 3.14)
?c
z
c(z, 555, z)
z * 2 + 100
my_sqrt <- sqrt(z - 1)
my_sqrt
my_div <- z / my_sqrt
my_div
c(1, 2, 3, 4) + c(0, 10)
c(1, 2, 3, 4) + c(0, 10, 100)
z * 2 + 100
z * 2 + 1000
my_div
bye()
swirl()
swirl()
clear
# the command:
setwd("/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2")
getwd()
# scalars
a <- 1
a
# In the classical R syntax, values are assigned by using "<-".
# In recent versions of R the assignment can be equivalently done
# through "="
a = 1
4 -> b
a <- b
b = 5
v <- c(2,3,5,4)
v
u <- seq(2,5,len=4)
u
u <- seq(2,5,by=1)
u
z <- 2:5
z
x <- seq(0,10, len= 100)
x
y <- seq(0, 20, len = 100)
plot(x,y)
# matrices
W <- rbind(c(11,13,15),c(12,14,16))
W
W <- cbind(c(11,12),c(13,14),c(15,16))
W
W <- matrix(data = c(11,12,13,14,15,16), nrow = 2, ncol = 3, byrow = F)
W
W <- matrix(c(11,12,13,14,15,16), 2, 3)
W
W <- matrix(data = c(11,12,13,14,15,16), nrow = 2, ncol = 3, byrow = T)
W
W <- matrix(c(11,12,13,14,15,16), 2, 3)
W
# if you remember the name of the command use
# help(COMMANDNAME)
# e.g.
help(matrix)
v
v[2]
v[c(2,3)]
v[-3]
v[-c(1,4)]
W
W[2,3]
W[2,c(2,3)]
W[2,]
W[,c(2,3)]
v
rbind(v)
cbind(v)
a <- 1
b <- 2
c <- c(2,3,4)
d <- c(10,10,10)
Z <- matrix(c(1,10,3,10,5,10), nrow = 2, ncol = 3, byrow = F)
a+b # scalar + scalar
c+d # vector + vector
a*b # scalar * scalar
a+b # scalar + scalar
c+d # vector + vector
a*b # scalar * scalar
c*d # vector * vector (component-wise)
t(c)*d
t(c) %*% d
c %*% d
c+a # vector + scalar
c^2 # attention: operations are always component-wise!
exp(c)
sum(c) # sums the components of c
prod(c) # returns the product of the components of c
V <- t(W) # transpose of a matrix
Z+W # matrix + matrix (component-wise)
Z*W # matrix * matrix (component-wise)
V*W # matrix * matrix (component-wise) (error!)
V %*% W # Matrix multiplication
W %*% V
W
a
W+a # matrix + scalar
c
W+c # matrix + vector
W+2:5
# Remark: R uses the "recycling", i.e., it tries to make the
# terms dimensions compatible by recycling data if missing
W+2:4 # recycling without warning!
# Inverse of a matrix (square and invertible)
A <- matrix(c(11,13,12,14), ncol=2, nrow=2, byrow=TRUE)
det(A)
solve(A)
# Solution of a linear system Ax=b
b <- c(1,1)
solve(A,b)
district <- c('MI',  'MI',  'VA',  'BG',  'LO', 'LO',  'CR',  'Alt', 'CR',  'MI',
'Alt', 'CR',  'LO',  'VA',  'MI',  'Alt', 'LO',  'MI')
district <- factor(district,levels=c('MI','LO','BG','CR','VA','Alt'))
district
resass <- table(district) # table of absolute frequencies
resass
resrel <- table(district)/length(district) # table of relative frequencies
resrel
exam <- list (course = 'Applied Statistics',
date = '27/09/2014',
enrolled = 7,
corrected = 6,
student_id = as.character(c(45020,45679,46789,43126,42345,47568,45674)),
evaluation = c(30,29,30,NA,25,26,27)
)
exam
exam$evaluation
exam[[6]]
exam <- data.frame(
student_id = factor(as.character(c(45020,45679,46789,43126,42345,47568,45674))),
evaluation_W = c(30,29,30,NA,25,26,17),
evaluation_O = c(28,30,30,NA,28,27,NA),
evaluation_P = c(30,30,30,30,28,28,28),
outcome  = factor(c('Passed','Passed','Passed','To be repeated','Passed','Passed','To be repeated')))
exam
exam$evaluation_W    # a data.frame is a particular kind of list!
exam[[2]]
exam[2,]
evaluation_W
attach(exam)
evaluation_W
detach(exam)
evaluation_W
evaluation_W
exam$evaluation_W    # a data.frame is a particular kind of list!
attach(exam)
evaluation_W
detach(exam)
evaluation_W
record <- read.table('record.txt', header=T)
getwd()
# the command:
setwd("/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2")
record <- read.table('record.txt', header=T)
l
ls
getwd()
# the command:
setwd("/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2")
getwd()
# the command:
setwd('/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2')
getwd()
setwd('/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2')
getwd()
setwd('/users/daniel/Desktop/SEM4/APPSTAT/LAB/LAB1+2')
getwd()
setwd('/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB4')
getwd()
success <- 0:20
plot(success, dbinom(success, size=20, prob=.3),type='h')
plot(success, dbinom(success, size=365, prob=.3),type='h')
success <- 0:365
plot(success, dbinom(success, size=365, prob=.3),type='h')
points(succes, dbin(success, size = 365, prob = 0.5), col = 'red')
points(success, dbin(success, size = 365, prob = 0.5), col = 'red')
points(success, dbinom(success, size = 365, prob = 0.5), col = 'red')
points(success, dbinom(success, size = 365, prob = 0.5), col = 'red', type = 'l')
plot(success, dbinom(success, size=365, prob=.3),type='h')
points(success, dbinom(success, size = 365, prob = 0.5), col = 'red', type = 'l')
points(success, dbinom(success, size = 365, prob = 0.1), col = 'red', type = 'l')
plot(success, dbinom(success, size=365, prob=.5),type='h')
ls()
rm(ls())
rm(list = ls())
library('sptimer')
install.packages('sptimer')
install.packages('spTimer')
library('sptimer')
library('spTimer')
data("NYdata")
head("NYdata")
force(NYdata)
head(NYdata)
dim(NYdata)
index <- as.factor(NY.data$s.index)
index <- as.factor(NYdata$s.index)
levels(index)
library(maps)
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
NYsite <- NYdata
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
NYsite<-unique(cbind(NYdata[,1:3]))
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
data(NYgrid)
head(NYgrid)
head(NYsite)
grid.coords<-unique(cbind(NYgrid[,8:9]))
#library(maps)
plot(grid.coords,pch=19,col=1)
map(database="state",regions="new york",add=TRUE)
levels(index)
dim(levels(index))
length(levels(index))
data(NYgrid)
head(NYgrid)
?spT.subset
levels(as.factor(NYgrid$s.index))
length(levels(as.factor(NYgrid$s.index)))
NYdata[8,]
NYdata[which(s.index == 8)]
NYdata[which(NYdata$s.index == 8),]
NYdata[which(NYdata$s.index == 1),]
##
# Read data
data(NYdata)
s<-c(8,11,12,14,18,21,24,28)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataValPred<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28))
DataValPred<-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) & Month == 8)))
# MCMC via Gibbs using default choices
set.seed(11)
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
print(post.gp)
##
# Read data
data(NYdata)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"))
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
s<-c(8,11,12,14,18,21,24,28)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
head(DataFit)
DataFit[which(DataFit$s.index == 1),]
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
print(post.gp)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"))
head(DataFit)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"))
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=NYdata, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
print(post.gp)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataValPred<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28))
DataValPred<-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) & Month == 8)))
# Define the coordinates
coords<-as.matrix(unique(cbind(DataFit[,2:3])))
pred.coords<-as.matrix(unique(cbind(DataValPred[,2:3])))
# MCMC via Gibbs will provide output in *.txt format
# from C routine to avoide large data problem in R
set.seed(11)
post.gp.fitpred <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=coords,
newcoords=pred.coords, newdata=DataValPred,
scale.transform="SQRT")
# Define the coordinates
coords<-as.matrix(unique(cbind(DataFit[,2:3])))
pred.coords<-as.matrix(unique(cbind(DataValPred[,2:3])))
# MCMC via Gibbs will provide output in *.txt format
# from C routine to avoide large data problem in R
set.seed(11)
post.gp.fitpred <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=coords,
newcoords=pred.coords, newdata=DataValPred,
scale.transform="SQRT")
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
reverse=TRUE)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataValPred<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28))
DataValPred<-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) & Month == 8)))
# Define the coordinates
coords<-as.matrix(unique(cbind(DataFit[,2:3])))
pred.coords<-as.matrix(unique(cbind(DataValPred[,2:3])))
# MCMC via Gibbs will provide output in *.txt format
# from C routine to avoide large data problem in R
set.seed(11)
post.gp.fitpred <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=coords,
newcoords=pred.coords, newdata=DataValPred,
scale.transform="SQRT")
View(post.gp)
print(post.gp.fitpred)
summary(post.gp.fitpred)
coef(post.gp.fitpred)
plot(post.gp.fitpred,residuals=TRUE)
names(post.gp.fitpred)
View(post.gp)
post.gp[["wp"]]
length(post.gp[["wp"]])
length(pred.gp[["sig2etap"]])
length(post.gp[["sig2etap"]])
plot(x = 1:4000, post.gp[["sig2etap"]], type = 'l', col = 'red')
quit
clear
clc
clc*()
clc()
View(post.gp.fitpred)
View(post.gp.fitpred)
View(post.gp)
post.gp[["sig2ep"]]
plot[x = 1:4000, y = post.gp.fitpred[['sig2ep']]
plot(x = 1:4000, y = post.gp.fitpred[['sig2ep']])
?matern
?Matern
?materncorr
MaternCorr(14, 1, 0.5)
??MaternCorr
library('geoR')
matern(14, 1, 0.5)
library("RProtoBuf")
setwd("/users/daniel/desktop/ar_gibbs")
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
#read proto vector file
vector_proto <- RProtoBuf::readProtoFiles(files = "proto/vector_it.proto")
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
}
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
line()
}
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
}
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
}
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
}
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
}
for (i in 1:10) {
plot(mu0[i,2000:3000], main = paste("mu ", i) ,  type = 'l');
lines(1:1000, rep(i, 1000), type = 'l', col = "green");
}
file_path_rho <- "cmake-build-debug/rho_serialized.bin"
binary_data_rho <- readBin(file_path_rho, "raw", file.info(file_path_rho)$size)
msg_rho <- read(scalar.full_scalar_it, binary_data_rho)
## read rho file
file_path_rho <- "cmake-build-debug/rho_serialized.bin"
binary_data_rho <- readBin(file_path_rho, "raw", file.info(file_path_rho)$size)
msg_rho <- read(scalar.full_scalar_it, binary_data_rho)
###### rho
#read proto scalar file
scalar_proto <- RProtoBuf::readProtoFiles(files = "proto/scalar_it.proto")
binary_data_rho <- readBin(file_path_rho, "raw", file.info(file_path_rho)$size)
msg_rho <- read(scalar.full_scalar_it, binary_data_rho)
list_rho <- as.list(msg_rho$scalar)
rho <- sapply(list_rho, function(x){x$value});
plot(rho[50:3000], type = 'l')
plot(rho[2000:3000], type = 'l')
lines(1:1000, rep(0.8, 1000), type = 'l', col = 'green')
dev.off()
plot(rho[50:3000], type = 'l')
plot(rho[2000:3000], type = 'l')
lines(1:1000, rep(0.8, 1000), type = 'l', col = 'green')
mean(rho[2000:3000])
## sig_eps
dev.off()
file_path_sig_eps <- "cmake-build-debug/sig_eps_serialized.bin"
binary_data_sig_eps <- readBin(file_path_sig_eps, "raw", file.info(file_path_sig_eps)$size)
msg_sig_eps <- read(scalar.full_scalar_it, binary_data_sig_eps)
list_sig_eps <- as.list(msg_sig_eps$scalar)
sig_eps <- sapply(list_sig_eps, function(x){x$value});
plot(sig_eps[2000:3000], type = 'l')
sig_eps <- sapply(list_sig_eps, function(x){x$value});
plot(sig_eps[2000:3000], type = 'l')
plot(1:1000,sig_eps[2000:3000], type = 'l')
