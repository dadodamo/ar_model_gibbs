a
# In the classical R syntax, values are assigned by using "<-".
# In recent versions of R the assignment can be equivalently done
# through "="
a = 1
4 -> b
a <- b
b = 5
v <- c(2,3,5,4)
v
u <- seq(2,5,len=4)
u
u <- seq(2,5,by=1)
u
z <- 2:5
z
x <- seq(0,10, len= 100)
x
y <- seq(0, 20, len = 100)
plot(x,y)
# matrices
W <- rbind(c(11,13,15),c(12,14,16))
W
W <- cbind(c(11,12),c(13,14),c(15,16))
W
W <- matrix(data = c(11,12,13,14,15,16), nrow = 2, ncol = 3, byrow = F)
W
W <- matrix(c(11,12,13,14,15,16), 2, 3)
W
W <- matrix(data = c(11,12,13,14,15,16), nrow = 2, ncol = 3, byrow = T)
W
W <- matrix(c(11,12,13,14,15,16), 2, 3)
W
# if you remember the name of the command use
# help(COMMANDNAME)
# e.g.
help(matrix)
v
v[2]
v[c(2,3)]
v[-3]
v[-c(1,4)]
W
W[2,3]
W[2,c(2,3)]
W[2,]
W[,c(2,3)]
v
rbind(v)
cbind(v)
a <- 1
b <- 2
c <- c(2,3,4)
d <- c(10,10,10)
Z <- matrix(c(1,10,3,10,5,10), nrow = 2, ncol = 3, byrow = F)
a+b # scalar + scalar
c+d # vector + vector
a*b # scalar * scalar
a+b # scalar + scalar
c+d # vector + vector
a*b # scalar * scalar
c*d # vector * vector (component-wise)
t(c)*d
t(c) %*% d
c %*% d
c+a # vector + scalar
c^2 # attention: operations are always component-wise!
exp(c)
sum(c) # sums the components of c
prod(c) # returns the product of the components of c
V <- t(W) # transpose of a matrix
Z+W # matrix + matrix (component-wise)
Z*W # matrix * matrix (component-wise)
V*W # matrix * matrix (component-wise) (error!)
V %*% W # Matrix multiplication
W %*% V
W
a
W+a # matrix + scalar
c
W+c # matrix + vector
W+2:5
# Remark: R uses the "recycling", i.e., it tries to make the
# terms dimensions compatible by recycling data if missing
W+2:4 # recycling without warning!
# Inverse of a matrix (square and invertible)
A <- matrix(c(11,13,12,14), ncol=2, nrow=2, byrow=TRUE)
det(A)
solve(A)
# Solution of a linear system Ax=b
b <- c(1,1)
solve(A,b)
district <- c('MI',  'MI',  'VA',  'BG',  'LO', 'LO',  'CR',  'Alt', 'CR',  'MI',
'Alt', 'CR',  'LO',  'VA',  'MI',  'Alt', 'LO',  'MI')
district <- factor(district,levels=c('MI','LO','BG','CR','VA','Alt'))
district
resass <- table(district) # table of absolute frequencies
resass
resrel <- table(district)/length(district) # table of relative frequencies
resrel
exam <- list (course = 'Applied Statistics',
date = '27/09/2014',
enrolled = 7,
corrected = 6,
student_id = as.character(c(45020,45679,46789,43126,42345,47568,45674)),
evaluation = c(30,29,30,NA,25,26,27)
)
exam
exam$evaluation
exam[[6]]
exam <- data.frame(
student_id = factor(as.character(c(45020,45679,46789,43126,42345,47568,45674))),
evaluation_W = c(30,29,30,NA,25,26,17),
evaluation_O = c(28,30,30,NA,28,27,NA),
evaluation_P = c(30,30,30,30,28,28,28),
outcome  = factor(c('Passed','Passed','Passed','To be repeated','Passed','Passed','To be repeated')))
exam
exam$evaluation_W    # a data.frame is a particular kind of list!
exam[[2]]
exam[2,]
evaluation_W
attach(exam)
evaluation_W
detach(exam)
evaluation_W
evaluation_W
exam$evaluation_W    # a data.frame is a particular kind of list!
attach(exam)
evaluation_W
detach(exam)
evaluation_W
record <- read.table('record.txt', header=T)
getwd()
# the command:
setwd("/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2")
record <- read.table('record.txt', header=T)
l
ls
getwd()
# the command:
setwd("/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2")
getwd()
# the command:
setwd('/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2')
getwd()
setwd('/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB1+2')
getwd()
setwd('/users/daniel/Desktop/SEM4/APPSTAT/LAB/LAB1+2')
getwd()
setwd('/users/daniel/desktop/SEM4/APPSTAT/LAB/LAB4')
getwd()
success <- 0:20
plot(success, dbinom(success, size=20, prob=.3),type='h')
plot(success, dbinom(success, size=365, prob=.3),type='h')
success <- 0:365
plot(success, dbinom(success, size=365, prob=.3),type='h')
points(succes, dbin(success, size = 365, prob = 0.5), col = 'red')
points(success, dbin(success, size = 365, prob = 0.5), col = 'red')
points(success, dbinom(success, size = 365, prob = 0.5), col = 'red')
points(success, dbinom(success, size = 365, prob = 0.5), col = 'red', type = 'l')
plot(success, dbinom(success, size=365, prob=.3),type='h')
points(success, dbinom(success, size = 365, prob = 0.5), col = 'red', type = 'l')
points(success, dbinom(success, size = 365, prob = 0.1), col = 'red', type = 'l')
plot(success, dbinom(success, size=365, prob=.5),type='h')
ls()
rm(ls())
rm(list = ls())
library('sptimer')
install.packages('sptimer')
install.packages('spTimer')
library('sptimer')
library('spTimer')
data("NYdata")
head("NYdata")
force(NYdata)
head(NYdata)
dim(NYdata)
index <- as.factor(NY.data$s.index)
index <- as.factor(NYdata$s.index)
levels(index)
library(maps)
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
NYsite <- NYdata
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
NYsite<-unique(cbind(NYdata[,1:3]))
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
map(database="state",regions="new york")
points(NYsite[,2:3],pch=19)
data(NYgrid)
head(NYgrid)
head(NYsite)
grid.coords<-unique(cbind(NYgrid[,8:9]))
#library(maps)
plot(grid.coords,pch=19,col=1)
map(database="state",regions="new york",add=TRUE)
levels(index)
dim(levels(index))
length(levels(index))
data(NYgrid)
head(NYgrid)
?spT.subset
levels(as.factor(NYgrid$s.index))
length(levels(as.factor(NYgrid$s.index)))
NYdata[8,]
NYdata[which(s.index == 8)]
NYdata[which(NYdata$s.index == 8),]
NYdata[which(NYdata$s.index == 1),]
##
# Read data
data(NYdata)
s<-c(8,11,12,14,18,21,24,28)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataValPred<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28))
DataValPred<-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) & Month == 8)))
# MCMC via Gibbs using default choices
set.seed(11)
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
print(post.gp)
##
# Read data
data(NYdata)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"))
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
s<-c(8,11,12,14,18,21,24,28)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
head(DataFit)
DataFit[which(DataFit$s.index == 1),]
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
print(post.gp)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"))
head(DataFit)
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"))
post.gp <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=NYdata, model="GP", coords=~Longitude+Latitude,
scale.transform="SQRT")
print(post.gp)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataValPred<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28))
DataValPred<-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) & Month == 8)))
# Define the coordinates
coords<-as.matrix(unique(cbind(DataFit[,2:3])))
pred.coords<-as.matrix(unique(cbind(DataValPred[,2:3])))
# MCMC via Gibbs will provide output in *.txt format
# from C routine to avoide large data problem in R
set.seed(11)
post.gp.fitpred <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=coords,
newcoords=pred.coords, newdata=DataValPred,
scale.transform="SQRT")
# Define the coordinates
coords<-as.matrix(unique(cbind(DataFit[,2:3])))
pred.coords<-as.matrix(unique(cbind(DataValPred[,2:3])))
# MCMC via Gibbs will provide output in *.txt format
# from C routine to avoide large data problem in R
set.seed(11)
post.gp.fitpred <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=coords,
newcoords=pred.coords, newdata=DataValPred,
scale.transform="SQRT")
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataFit<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
reverse=TRUE)
DataFit<-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) & Month == 8)))
DataValPred<-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28))
DataValPred<-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) & Month == 8)))
# Define the coordinates
coords<-as.matrix(unique(cbind(DataFit[,2:3])))
pred.coords<-as.matrix(unique(cbind(DataValPred[,2:3])))
# MCMC via Gibbs will provide output in *.txt format
# from C routine to avoide large data problem in R
set.seed(11)
post.gp.fitpred <- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,
data=DataFit, model="GP", coords=coords,
newcoords=pred.coords, newdata=DataValPred,
scale.transform="SQRT")
View(post.gp)
print(post.gp.fitpred)
summary(post.gp.fitpred)
coef(post.gp.fitpred)
plot(post.gp.fitpred,residuals=TRUE)
names(post.gp.fitpred)
View(post.gp)
post.gp[["wp"]]
length(post.gp[["wp"]])
length(pred.gp[["sig2etap"]])
length(post.gp[["sig2etap"]])
plot(x = 1:4000, post.gp[["sig2etap"]], type = 'l', col = 'red')
quit
clear
clc
clc*()
clc()
View(post.gp.fitpred)
View(post.gp.fitpred)
View(post.gp)
post.gp[["sig2ep"]]
plot[x = 1:4000, y = post.gp.fitpred[['sig2ep']]
plot(x = 1:4000, y = post.gp.fitpred[['sig2ep']])
?matern
?Matern
?materncorr
MaternCorr(14, 1, 0.5)
??MaternCorr
library('geoR')
matern(14, 1, 0.5)
library("RProtoBuf")
setwd("/users/daniel/desktop/ar_gibbs")
#### o's
matrix_proto <- RProtoBuf::readProtoFiles(files = "proto/o.proto")
file_path_o <- "cmake-build-debug/o_serialized.bin"
binary_data_o <- readBin(file_path_o, "raw", file.info(file_path_o)$size)
msg_o <- read(o_data.full_o_it, binary_data_o)
list_o <- as.list(msg_o$m)
list_o <- as.list(msg_o$m)
o <- sapply(list_o, function(x){x$vec});
o <- sapply(o, function(x){x$vec_value});
o0 <- matrix(0, ncol = 5000, nrow = 10);
col = 1;
for(i in seq(1,999801 , 200)){
o0[,col] = o[,i];
col = col + 1;
}
plot(o0[1,], type = "l")
mean(o0[1,])
plot(o0[2,], type = "l")
mean(o0[2,])
plot(o0[3,], type = "l")
mean(o0[3,])
plot(o0[4,], type = "l")
mean(o0[4,])
plot(o0[5,], type = "l")
mean(o0[5,])
plot(o0[6,], type = "l")
mean(o0[6,])
plot(o0[7,], type = "l")
mean(o0[7,])
plot(o0[8,], type = "l")
mean(o0[8,])
plot(o0[9,], type = "l")
mean(o0[9,])
plot(o0[10,], type = "l")
mean(o0[10,])
binary_data_beta <- readBin(file_path_beta, "raw", file.info(file_path_beta)$size)
#read proto vector file
vector_proto <- RProtoBuf::readProtoFiles(files = "proto/vector_it.proto")
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(1:3000, rep(i+1, 3000), type = 'l', col = "green");
}
plot(mu0[1,1000:5000] ,  type = 'l', col = 'grey');
dev.off()
plot(mu0[1,1000:5000] ,  type = 'l', col = 'grey');
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
plot(mu0[1,1000:5000] ,  type = 'l', col = 'grey');
#### o's
matrix_proto <- RProtoBuf::readProtoFiles(files = "proto/o.proto")
file_path_o <- "cmake-build-debug/o_serialized.bin"
binary_data_o <- readBin(file_path_o, "raw", file.info(file_path_o)$size)
msg_o <- read(o_data.full_o_it, binary_data_o)
list_o <- as.list(msg_o$m)
list_o <- as.list(msg_o$m)
o <- sapply(list_o, function(x){x$vec});
o <- sapply(o, function(x){x$vec_value});
o0 <- matrix(0, ncol = 5000, nrow = 10);
col = 1;
for(i in seq(1,999801 , 200)){
o0[,col] = o[,i];
col = col + 1;
}
plot(o0[1,], type = "l")
mean(o0[1,])
var(o0[1,2000:3000])
var(o0[9,])
o0 <- matrix(0, ncol = 5000, nrow = 10);
col = 1;
for(i in seq(1,999801 , 200)){
o0[,col] = o[,i];
col = col + 1;
}
plot(o0[1,], type = "l")
plot(o0[2,], type = "l")
mean(o0[2,])
plot(o0[3,], type = "l")
mean(o0[3,])
plot(o0[4,], type = "l")
mean(o0[4,])
plot(o0[5,], type = "l")
mean(o0[5,])
plot(o0[6,], type = "l")
mean(o0[6,])
plot(o0[7,], type = "l")
mean(o0[7,])
plot(o0[8,], type = "l")
mean(o0[8,])
plot(o0[9,], type = "l")
mean(o0[9,])
plot(o0[10,], type = "l")
mean(o0[10,])
## read file
file_path_mu0 <- "cmake-build-debug/mu0_serialized.bin"
binary_data_mu0 <- readBin(file_path_mu0, "raw", file.info(file_path_mu0)$size)
msg_mu0 <- read(vector.full_iter_vec, binary_data_mu0)
list_mu0 <- as.list(msg_mu0$vec_t)
mu0 <- sapply(list_mu0, function(x){x$vec_value});
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(1:3000, rep(i+1, 3000), type = 'l', col = "green");
}
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(1000:5000, rep(i+1, 4000), type = 'l', col = "green");
}
length(1000:4000)
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(1000:5000, rep(i+1, 4001), type = 'l', col = "green");
}
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(0:4000, rep(i+1, 4000), type = 'l', col = "green");
}
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(1:4000, rep(i+1, 4000), type = 'l', col = "green");
}
plot(mu0[1,1000:5000] ,  type = 'l', col = 'grey');
dev.off()
par(mfrow = c(5, 2))
par(mar = c(2, 4, 2, 1))
for (i in 1:10) {
plot(mu0[i,1000:5000], main = paste("mu ", i) ,  type = 'l', col = 'grey');
lines(1:4000, rep(i+1, 4000), type = 'l', col = "green");
}
#### o's
matrix_proto <- RProtoBuf::readProtoFiles(files = "proto/o.proto")
file_path_o <- "cmake-build-debug/o_serialized.bin"
binary_data_o <- readBin(file_path_o, "raw", file.info(file_path_o)$size)
msg_o <- read(o_data.full_o_it, binary_data_o)
list_o <- as.list(msg_o$m)
list_o <- as.list(msg_o$m)
o <- sapply(list_o, function(x){x$vec});
o <- sapply(o, function(x){x$vec_value});
o0 <- matrix(0, ncol = 5000, nrow = 10);
col = 1;
for(i in seq(1,999801 , 200)){
o0[,col] = o[,i];
col = col + 1;
}
dev.off()
plot(o0[1,], type = "l")
mean(o0[1,])
plot(o0[2,], type = "l")
mean(o0[2,])
plot(o0[3,], type = "l")
mean(o0[3,])
plot(o0[4,], type = "l")
mean(o0[4,])
plot(o0[5,], type = "l")
mean(o0[5,])
plot(o0[6,], type = "l")
mean(o0[6,])
plot(o0[7,], type = "l")
mean(o0[7,])
plot(o0[8,], type = "l")
mean(o0[8,])
